# 消息中间件
> 工作台需要一个消息中间件，用于处理常规的消息的发送和接收，同时还会执行工作台内部的任务调度操作.
> 但是直接引入一个类似于MQ之类的消息中间件，在应用all-in-one部署时,无疑会增加部署的复杂度。
> 所以我们需要一个轻量级的消息中间件，用于处理消息的发送和接收。

## 设计目标
- 轻量级
- 支持多种消息传递方式
- 解耦底层链接
- 支持双向通信
- 支持消息信道

## 核心组件

## 交互方式
1. 客户端向服务端创建链接
2. 服务端响应客户端的同时,向客户端发送一个消息
3. 交换基础配置,包括:
   - 序列化方式
   - 消息传递方式
   - 消息信道
   - 其他

# 一条消息的一生

客户端根据自己的业务创建消息,交给客户端的MessageSender处理,MessageSender接受任意类型的消息,并将其序列化为字节流
,然后将其发送到消息的接收方.

MessageSender除了传递消息本身之外,还会填充消息的元数据,比如:
- 为消息创建一个唯一的ID
- 为消息设置发送时间,当前Sender的标志等
- 同时,如果MessageSender若是设置了全局的回传信息,则会将回传信息填充到消息的元数据中,如果Message本身提供了回传信息,则会合并两者的回传信息。
  > 回传信息是指,当消息接收方处理完消息后,需要将回传数据原封不动的返回给消息发送方的信息。

  > 😁: 回传信息的作用是什么?
  >  - 用于消息的状态跟踪
  >  - 可以实现消息的双向通信
  >  - 可以实现消息的请求/响应模式
  >  - 可以实现消息的任务调度
借助于回传信息,我们可以实现消息的双向通信,消息的请求/响应模式,消息的任务调度等功能。

比如`ChannelMessageSende`r会为消息填充消息信道的信息,当消息的接受者处理完成处理后,可以回传信道信息,用于消息的双向通信。


### 和AMQP/MQTT的区别
在设计上,`CMCWM`(`cat-man-coder-workbench-message`)是结合工作台业务特点设计的跨组件消息中间件,其虽然具有一定的一致性,
但其本质上并不是一个真正的消息中间件,只不过其提供了一些消息中间件的基本功能,用于支持工作台的消息传递和任务调度。
其和AMQP/MQTT的区别主要是,其实现必然支持双向通信.

###  为什么不实现JMS?
> 虽然工作台的主要组成部分由JAVA编写,但是工作台同样支持其他编程语言创建的工作节点或执行器,所以,面向JAVA的JMS并不是一个好的选择。

### 为什么不实现AMQP或者MQTT?
> AMQP/MQTT是一个很好的消息中间件协议，但是它的实现比较复杂，而且在一些场景下，我们并不需要这么复杂的消息中间件。


